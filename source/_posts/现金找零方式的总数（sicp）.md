---
title: 现金找零方式的总数（sicp）
date: 2018-04-10 13:42:31
tags: [算法, sicp]
categories: 技术
---
**问题：现有现金a，并且有n种面额的零钱，问，共有多少种找零方式。**
问题细化：现有现金1元，并且有50分，25分，10分，5分，1分五种面额，用这5种零钱组成1元，共有多少种方式？
<!-- more -->
---
如果把n种零钱按照某种顺序排列（如50分，25分，10分，5分，1分，不一定升序或降序，也可以乱序），那么问题可以转化为：
**现金a用除第一种零钱之外其他面额的找零方式数目**
加上
**现金a-d用所有面额的找零方式数目，其中d为第一种零钱的面额**

为什么？什么逻辑？有点晕，看不懂？没关系接着往下看。

上面的逻辑等同于
**使用第一种零钱的次数为0次，现金a找零方式数目**
加上
**使用第一种零钱的次数为>=1次，现金a找零方式数目**
如果减去1个第一种零钱，那么等价于**"使用第一种零钱的次数为>=0次，现金a-d找零方式数目"**，亦即**"现金a-d用所有面额的找零方式数目，其中d为第一种零钱的面额"**


----------


弄明白上面的逻辑，就看例子吧：以50分，25分，10分，5分，1分为序列，现金额度为1元，则找零方式总数
等于


> 1元完全不用50分 + 50分用50，25，10，5，1分//现在第一种零钱为50分

等于


> 1元完全不用50分 + (50分完全不用50分 + 0分用50，25，10，5，1分)//现在第一种零钱为50分

等于


> 1元用25，10，5，1分 + 50分用25，10，5，1分
> //"完全不用50分"等价于"用25，10，5，1分"，“0分用50，25，10，5，1分”是0

等于


> (1元完全不用25分 + 75分用25，10，5，1分)// 现在硬币总数只有4种,第一种是25分
> +
> (50分完全不用25分 + 25分用25，10，5，1分)// 现在硬币总数只有4种,第一种是25分

等于


> (1元完全不用25分 + (75分完全不用25分 + 50分用25，10，5，1分))// 现在硬币总数只有4种,第一种是25分
> +
> (50分完全不用25分 + (25分完全不用25分 + 0分用25，10，5，1分))// 现在硬币总数只有4种,第一种是25分

。。。。一直循环下去


----------


代码实现（js）

```javascript
const kindsOfCoins = [1, 5, 10, 25, 50];

/**
 * 如果amount正好为0
 * 现金amount，用kinds种硬币的找零方式总数，
 * 等于现金amount，用除了第一种硬币之外其他硬币的找零方式总数 + 现金amount - d用所有硬币的找零方式总数（d为第一种硬币的面值）
 * amount为0，说明前一步amount-firstCoins正好为0，比如25-25，是1种找零方式，return 1
 * amount<0，说明前一步amount-firstCoins类似于10-25，不是找零方式，return 0
 * kinds===0，说明没有找零的硬币了，return 0
 *
 * @param amount 总金额
 * @param kinds  硬币种类数
 * @returns {*}
 */
function countChange(amount, kinds) {
    const restKindsOfCoins = kindsOfCoins.slice(0, kinds);
    const firstCoins = restKindsOfCoins[kinds - 1];
    if (amount === 0) return 1;
    if (amount < 0) return 0;
    if (kinds === 0) return 0;
    return countChange(amount, kinds - 1) + countChange(amount - firstCoins, kinds);
}

console.log(countChange(100, 5));// 292
```
注意，如果``const kindsOfCoins = [1, 5, 10, 25, 50];``改为``const kindsOfCoins = [50, 10, 5, 1, 25];``得出的结果是一样的，也就是说零钱的随便怎么排序都可以。
